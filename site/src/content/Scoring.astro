---
// IgcScorer.astro
// Requires: npm install igc-xc-score igc-parser
---

<div class="flex flex-col gap-4 w-full">
  <label
    id="drop-zone"
    class="flex flex-col items-center justify-center gap-2 p-8 border-2 border-dashed border-gray-300 rounded-lg cursor-pointer hover:border-blue-500 hover:bg-blue-50 transition-colors"
  >
    <svg xmlns="http://www.w3.org/2000/svg" class="w-8 h-8 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
      <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" />
    </svg>
    <span class="text-sm text-gray-600">Drop an IGC file or click to browse</span>
    <input
      id="igc-input"
      type="file"
      accept=".igc"
      class="hidden"
    />
  </label>

  <div id="status" class="text-center text-sm text-gray-500 hidden"></div>

  <div id="results" class="hidden rounded-lg border border-gray-200 bg-white p-4">
    <h3 class="font-semibold text-lg mb-3">Score Results</h3>
    <dl id="results-list" class="grid grid-cols-[auto_1fr] gap-x-4 gap-y-2 text-sm">
    </dl>
  </div>
</div>

<script>
  import IGCParser from 'igc-parser';
  import { solver, scoringRules as scoring } from 'igc-xc-score';

  const input = document.getElementById('igc-input') as HTMLInputElement;
  const dropZone = document.getElementById('drop-zone')!;
  const status = document.getElementById('status')!;
  const results = document.getElementById('results')!;
  const resultsList = document.getElementById('results-list')!;

  function showStatus(msg: string, isError = false) {
    status.textContent = msg;
    status.classList.remove('hidden', 'text-red-600', 'text-gray-500');
    status.classList.add(isError ? 'text-red-600' : 'text-gray-500');
  }

  function addResult(label: string, value: string) {
    const dt = document.createElement('dt');
    dt.className = 'text-gray-500';
    dt.textContent = label;
    const dd = document.createElement('dd');
    dd.className = 'font-medium';
    dd.textContent = value;
    resultsList.append(dt, dd);
  }

  function scoreFile(content: string) {
    try {
      const flight = IGCParser.parse(content, { lenient: true });

      showStatus('Scoring flight…');

      const triangleScoringRules = scoring.XContest
        .filter(r => r.code === 'tri' || r.code === 'fai')
        .map(r => ({
            ...r,
            closingDistanceRelative: 0.8,
            closingDistanceFree: 0,
            closingDistanceFixed: 0,
      }));
      const gen = solver(flight, triangleScoringRules);
      let best = gen.next().value;

      // Iterate until optimal or 100 cycles
      let cycles = 0;
      while (!best.optimal && cycles < 100) {
        const next = gen.next().value;
        if (next) best = next;
        else break;
        cycles++;
      }

      // Display results
      resultsList.innerHTML = '';
      console.log(best.scoreInfo);
      addResult('Distance', best.scoreInfo?.distance?.toFixed(2) + ' km');
      addResult('Type', best.opt?.scoring?.name ?? '—');
      addResult('Penalty', best.scoreInfo?.penalty.toFixed(2) ?? '-');

      if (best.scoreInfo?.tp) {
        best.scoreInfo.tp.forEach((tp: { x: number; y: number }, i: number) => {
          addResult(`TP ${i + 1}`, `${tp.y.toFixed(5)}, ${tp.x.toFixed(5)}`);
        });
      }

      if (best.scoreInfo?.cp) {
        addResult(`CP 1`, `${best.scoreInfo?.cp?.in.x.toFixed(5)}, ${best.scoreInfo?.cp?.in.x.toFixed(5)}`)
        addResult(`CP 2`, `${best.scoreInfo?.cp?.in.x.toFixed(5)}, ${best.scoreInfo?.cp?.in.x.toFixed(5)}`)
      }

      results.classList.remove('hidden');
      showStatus('Done.');

      // Dispatch event for FlightMap (or any other listener)
      document.dispatchEvent(
        new CustomEvent('igc-score-result', {
          detail: { flight, result: best },
        })
      );
    } catch (e: any) {
      showStatus('Error: ' + e.message, true);
      results.classList.add('hidden');
    }
  }

  function handleFile(file: File) {
    if (!file.name.toLowerCase().endsWith('.igc')) {
      showStatus('Please select an .igc file.', true);
      return;
    }
    showStatus('Reading file…');
    const reader = new FileReader();
    reader.onload = () => scoreFile(reader.result as string);
    reader.onerror = () => showStatus('Failed to read file.', true);
    reader.readAsText(file);
  }

  input.addEventListener('change', () => {
    if (input.files?.[0]) handleFile(input.files[0]);
  });

  // Drag and drop
  dropZone.addEventListener('dragover', (e) => {
    e.preventDefault();
    dropZone.classList.add('border-blue-500', 'bg-blue-50');
  });
  dropZone.addEventListener('dragleave', () => {
    dropZone.classList.remove('border-blue-500', 'bg-blue-50');
  });
  dropZone.addEventListener('drop', (e) => {
    e.preventDefault();
    dropZone.classList.remove('border-blue-500', 'bg-blue-50');
    if (e.dataTransfer?.files?.[0]) handleFile(e.dataTransfer.files[0]);
  });
</script>